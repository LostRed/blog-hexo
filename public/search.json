[{"title":"自定义Spring Boot Starter","url":"/posts/customizm-spring-boot-starter.html","content":"Spring Boot Starter是Spring Boot中的一个重要机制，它通常由AutoConfiguration和Properties类组成，在程序加载时自动对Spring上下文环境进行配置。其实Spring Boot Starter的任务就是在Spring Boot应用启动前完成自动配置。\n\n注意：Spring官方提供的Starter包命名方式为spring-boot-starter-xxx，而第三方Starter包的命名方式为xxx-spring-boot-starter。\n\n下面我们来看看如何自定义一个Spring Boot Starter。\n创建Maven工程\n创建一个maven工程，artifactId起名为xxx-spring-boot-starter，groupId不可在org.springframework路径下。\n引入依赖\n引入spring-boot-dependencies下的autoconfigure和configuration-processor，autoconfigure提供自动配置支持，而configuration-processor是给开发人员在IDE环境配置application.properties或application.yaml时，提供上下文帮助、提示和跳转支持。\n&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;        &lt;optional&gt;true&lt;/optional&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n编写自动配置类\n在编写配置类之前，我们需要先了解一下Spring Boot的自动配置原理。\n@Configuration@EnableConfigurationProperties(MyProperties.class)public class MyAutoConfiguration &#123;     @Resource    private MyProperties properties;        // 编写自己注册Bean的方法&#125;\n\n在resources目录下创建META-INF/spring.factories文件，并在org.springframework.boot.autoconfigure.EnableAutoConfiguration下添加自动配置类的全限定类名。\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\info.lostred.autoconfigure.MyAutoConfiguration\n\n编写配置绑定\n创建Properties类并指定配置项前缀。\n@ConfigurationProperties(prefix = &quot;my&quot;)public class MyProperties &#123;    private String name;        public String getName()&#123;        return name;    &#125;        public void setName(String name)&#123;        this.name = name;    &#125;&#125;\n\n在application.properties中配置配置项，可以看到IDE有配置项的提示。\nmy.name=lostred\n\n编写配置元数据\n\n如果用Properties绑定了配置，这步可以省略。\n\n在resources目录下创建META-INF/additional-spring-configuration-metadata.json文件。\n&#123;    &quot;properties&quot;: [        &#123;            &quot;name&quot;: &quot;my.name&quot;,            &quot;type&quot;: &quot;java.lang.Boolean&quot;,            &quot;sourceType&quot;: &quot;info.lostred.autoconfigure.MyAutoConfiguration&quot;,            &quot;description&quot;: &quot;我的名字.&quot;,            &quot;defaultValue&quot;: &quot;lostred&quot;        &#125;    ]&#125;\n\n打包发布Starter\n将项目打包后发布到maven仓库，这样其它工程就可以依赖该xxx-spring-boot-starter实现自动配置。\n","categories":["Java"],"tags":["Java","Spring Boot"]},{"title":"Healthcare Filter Boot Starter","url":"/posts/healthcare-filter-boot-starter.html","content":"Healthcare Filter Boot Starter是质控启动器，程序启动时将在Spring容器中注册一个RuleChain实现类对象，开箱即用。\n特性\n\n结算清单的整体质控实现模式是若干条校验规则组成的责任链模式，即校验规则链\n校验规则链的规则执行器有两种模式可供选择，默认详细执行器会记录违规字段和违规值，而简单执行器则不会记录违规字段和违规值\n校验规则链的规则迭代器有两种模式可供选择，默认全量迭代器会依次通过所有校验规则校验，除非在质控结果中包含”US”校验规则代号(即唯一校验)的错误记录，而跳出迭代器会在出现错误信息后直接结束校验\n规则执行器每执行一个规则，且发现有违规项目时，会在校验结果中添加一个记录\n经过所有校验规则校验后，会生成一个校验结果返回值，校验结果等级分为“合格”、“可疑”和“违规”\n\n快速开始\n引入依赖\n仓库地址：http://10.16.0.127:8081/nexus/repository/maven-public/\n\n&lt;dependency&gt;    &lt;groupId&gt;com.ylzinfo.hf.boot&lt;/groupId&gt;    &lt;artifactId&gt;healthcare-filter-boot-starter&lt;/artifactId&gt;    &lt;version&gt;last-version&lt;/version&gt;&lt;/dependency&gt;\n\n配置# 配置Springspring:  # 数据源  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://ip:port/db?useUnicode=true&amp;characterEncoding=utf8    username: username    password: password  # JPA  jpa:    open-in-view: false# 配置校验规则healthcare:  # 配置自定义表名  table-name:    rule-info: rule_info  # 配置编码版本  context:    icd10:      enable: true # 是否启用《ICD-10》      version: 2   # 版本    icd9cm3:      enable: true # 是否启用《ICD-9-CM-3》      version: 2   # 版本    quality:      enable: true # 是否启用质控相关术语集    tcm:      enable: true # 是否启用中医编码  # 配置质控模块  filter:    # 配置校验规则链模式    rule-chain:      rule-executor: detailed     # 配置执行器，不配置默认为detailed      rule-iterator: full         # 配置迭代器，不配置默认为full    # 唯一字段(参考系统要求的接口文档)    unique:      setl-info-fields:        - rid    # 必填字段(参考系统要求的接口文档)    required:      setl-info-fields:        - mdtrtId        - setlId\n\n\n首次运行程序，程序会检测校验规则信息表，当表不存在时，会重新初始化表格(配置非默认自定义表名则失效)，目前只支持mysql数据库\n\n自定义规则\n无二次开发可跳过此步骤\n\n\n创建一个Java类继承Rule类，实现其方法\npublic class TestRule extends Rule implements ErrorRecord &#123;    // 必须重写父类的isResponsible()方法，定义校验规则的校验条件    @Override    public boolean isResponsible(SetlList setlList) &#123;        return true;    &#125;    // 简单执行器会执行的判断方法，返回true表示违规，false表示未违规    // 该方法在判断出违规后直接返回true，可提升校验的执行速度    @Override    public boolean judge(SetlList setlList) &#123;        return false;    &#125;    // 详细执行器会执行的判断方法，返回true表示违规，false表示未违规    // 请将违规字段和违规值用QualityPoint类包装后加入集合    @Override    public boolean judge(SetlList setlList, List&lt;QualityPoint&gt; qualityPoints) &#123;        return false;    &#125;&#125;\n\n\n可疑类规则可直接实现WarnRecord接口，违规类规则可直接实现ErrorRecord，省去重写Record接口的write()方法    \n\n可继承的基类：com.ylzinfo.hf.filter.Rule\t\t        //结算清单抽象校验规则com.ylzinfo.hf.filter.QualityRule\t\t//结算清单质量校验规则com.ylzinfo.hf.filter.LogicRule\t\t\t//结算清单逻辑校验规则com.ylzinfo.hf.filter.DictRule\t\t\t//结算清单字典校验规则com.ylzinfo.hf.filter.ObjectDictRule\t        //结算清单对象类节点字典校验规则com.ylzinfo.hf.filter.ListDictRule\t\t//结算清单集合类节点字典校验规则com.ylzinfo.hf.filter.RequiredRule\t\t//结算清单必填校验规则com.ylzinfo.hf.filter.ObjectRequiredRule\t//结算清单对象类节点必填校验规则com.ylzinfo.hf.filter.ListRequiredRule\t\t//结算清单集合类节点必填校验规则com.ylzinfo.hf.filter.UniqueRule\t\t//结算清单唯一校验规则com.ylzinfo.hf.filter.ObjectUniqueRule\t\t//结算清单对象类节点唯一校验规则com.ylzinfo.hf.filter.ListUniqueRule\t\t//结算清单集合类节点唯一校验规则\n在规则信息表中添加相关的规则信息\n  insert into rule_info (rule_code, rule_type, item_type, item, grade, rule_desc, class_name, seq, phase, must, enable) values (&#x27;DS10&#x27;, &#x27;规则类型&#x27;, &#x27;质控类型&#x27;, &#x27;质控项目&#x27;, &#x27;违规&#x27;, &#x27;规则描述&#x27;, &#x27;Java类名&#x27;, 1, 0, 0, 1);\n\n\nseq字段是指规则执行的先后顺序，数字小的优先执行phase字段表示规则生效环节，可使用数字代表不同的环节must字段表示是否为必选规则enable字段表示该规则是否启用\n\n\n\n使用RuleChain@RestController@RequestMapping(&quot;/setlList&quot;)public class CaseController &#123;    @Resource    private RuleChain ruleChain;    @PostMapping(&quot;/validateDetails&quot;)    public QualityResult validate(@RequestBody NationSetlList setlList) &#123;        // 调用handle()方法进行校验                    return ruleChain.handle(setlList);                                 &#125;&#125;\n\n\nNationSetlList是约定的国家基线版结算清单数据报文RuleChain是filter包中的一个核心类，实现对病案数据的校验QualityResult是校验结果的统一返回格式\n\n高级功能\n忽略规则忽略的规则在会被RuleChain直接跳过，通过addIgnoredRules()和removeIgnoredRules()，可以对忽略规则进行添加和移除。\n设置执行器目前规则执行器有两种，通过RuleExecutor接口可以扩展新的执行器实现类，并设置为RuleChain的执行器。\n设置迭代器目前规则迭代器有两种，通过RuleIterator接口可以扩展新的迭代器实现类，并设置为RuleChain的迭代器。\n@RestController@RequestMapping(&quot;/setlList&quot;)public class CaseController &#123;    @Resource    private RuleChain ruleChain;    @PostMapping(&quot;/validateDetails&quot;)    public QualityResult validate(@RequestBody NationSetlList setlList) &#123;        // 可手动设置执行器        ruleChain.setRuleExecutor(new DetailedRuleExecutor());        // 可手动设置迭代器                   ruleChain.setRuleIterator(new FullRuleIterator());        // 添加忽略的规则        ruleChain.addIgnoredRules(Arrays.asList(AcpInsRule.class));        // 调用handle()方法进行校验              QualityResult qualityResult = ruleChain.handle(setlList);        // 移除忽略的规则        ruleChain.removeIgnoredRules(Arrays.asList(AcpInsRule.class));        return qualityResult;    &#125;&#125;\n\n\n更多内容请移步：Healthcare Filter\n\n","categories":["项目"],"tags":["Java","Healthcare Boot"]},{"title":"Healthcare Classify Boot Starter","url":"/posts/healthcare-classify-boot-starter.html","content":"Healthcare Classify Boot Starter是分组启动器，程序启动时将根据配置在Spring容器中注册一个分组器对象，开箱即用。\n特性\n\n病案结算清单分组器有两套实现，一个是DIP分组器，一个是DRG分组器\nDIP分组器中分值修正部分需要根据不同地市的政策配置不同的策略Bean\n\n快速开始\n引入依赖\n仓库地址：http://10.16.0.127:8081/nexus/repository/maven-public/\n\n&lt;dependency&gt;    &lt;groupId&gt;com.ylzinfo.hf.boot&lt;/groupId&gt;    &lt;artifactId&gt;healthcare-classify-boot-starter&lt;/artifactId&gt;    &lt;version&gt;last-version&lt;/version&gt;&lt;/dependency&gt;\n\n添加json文件\n在resource/data下存放一个DIP目录库的json文件，对应类DipGroup的字段，示例如下：\n[    &#123;        &quot;diagCode&quot;: &quot;N20.0&quot;,        &quot;diagName&quot;: &quot;肾结石&quot;,        &quot;oprnCode&quot;: &quot;55.0300x005&quot;,        &quot;oprnName&quot;: &quot;经皮肾造口术&quot;,        &quot;rw&quot;: 2.8214,        &quot;cv&quot;: 0.3007,        &quot;cal&quot;: 16,        &quot;total&quot;: 18,        &quot;mark&quot;: &quot;核心病种&quot;,        &quot;dip&quot;: &quot;2613&quot;,        &quot;base&quot;: false    &#125;]\n在resource/data下存放一个医药机构信息集合的json文件，对应类Fixmedins的字段，示例如下：\n[    &#123;        &quot;area&quot;: &quot;荆州&quot;,        &quot;fixmedinsCode&quot;: &quot;42100230001&quot;,        &quot;fixmedinsName&quot;: &quot;荆州市第一人民医院&quot;,        &quot;coefficient&quot;: &quot;1&quot;,        &quot;grade&quot;: 3,        &quot;gradeName&quot;: &quot;三级甲等&quot;    &#125;]\n在resource/data下存放一个分值修正标准集合的json文件，对应类RectifyCriteria的字段，示例如下：\n[    &#123;        &quot;index&quot;: &quot;S3:P80-P83+2&quot;,        &quot;total&quot;: 1,        &quot;amount&quot;: 6679.62,        &quot;average&quot;: 6679.62,        &quot;upperLimit&quot;: 13359.24,        &quot;lowerLimit&quot;: 3339.81    &#125;]\n\n配置healthcare:  # 配置分组器  classify:    json:      # 地方dip目录库json文件名      local-dip-grouping-database: dip-group-jingzhou      # 地方医药机构信息集合json文件名      fixmedins: fixmedins-jingzhou      # 地方分值修正标准集合json文件名      rectify-criteria: criteria-jingzhou      # 范围内的手术操作编码集合json文件名      # 如果使用了OprnPreProcessor，则需要在resource/data下提供范围内的手术操作编码集合的json文件      # 版本号以-1或-2结尾，配置时不需要带上版本号      included-oprn-code: included-oprn-code\n\n编写配置类@Configurationpublic class Jingzhou implements InitializingBean &#123;    //前置处理器    @Bean    public PreProcessor preProcessor(@Qualifier(&quot;includedOprnCodeSet&quot;) Set&lt;String&gt; includedOprnCodeSet) &#123;        return new DefaultPreProcessor(includedOprnCodeSet);    &#125;    //核心病种分组器，需要传入手术类型集合和地方病种目录库    @Bean    public CoreClassifier coreClassifier(Map&lt;String, Integer&gt; oprnTypeMap, Map&lt;String, DipGroup&gt; localDipGroupingDatabaseMap) &#123;        return new DefaultCoreClassifier(oprnTypeMap, localDipGroupingDatabaseMap);    &#125;    //综合病种分组器，需要传入手术类型集合和地方病种目录库    @Bean    public MixedClassifier mixedClassifier(Map&lt;String, Integer&gt; oprnTypeMap, Map&lt;String, DipGroup&gt; localDipGroupingDatabaseMap) &#123;        return new SecMixedClassifier(oprnTypeMap, localDipGroupingDatabaseMap);    &#125;    //未入组后置处理器    @Bean    public NonePostProcessor nonePostProcessor() &#123;        return new NonePostProcessor() &#123;            //实现政策文件内容，将指标初始化到convertCriteria中            @Override            protected void initConvertCriteria() &#123;                super.convertCriteria = new ConvertCriteria();                convertCriteria.setAverage(new BigDecimal(&quot;7955.52&quot;));                convertCriteria.setTotal(new BigDecimal(674366));                convertCriteria.setAmount(new BigDecimal(&quot;5364931772.57&quot;));                convertCriteria.setCoefficient(new BigDecimal(&quot;0.8&quot;));            &#125;            //实现可能的总金额动态调整            @Override            protected void adjust(BigDecimal amount) &#123;            &#125;        &#125;;    &#125;    //评估修正标准，需要注入定点医药机构集合和分值修正标准集合    @Bean    public Evaluator evaluator(Map&lt;String, Fixmedins&gt; fixmedinsMap, Map&lt;String, RectifyCriteria&gt; rectifyCriteriaMap) &#123;        return new LastYearWithGradeEvaluator(fixmedinsMap, rectifyCriteriaMap);    &#125;    //分值修正器，需要注入定点医药机构集合    @Bean    public Rectifier rectifier(Map&lt;String, Fixmedins&gt; fixmedinsMap) &#123;        return new AutoRectifier(fixmedinsMap);    &#125;    //设置上下限因子    @Override    public void afterPropertiesSet() &#123;        DipClassifierConstant.UPPER_LIMIT_FACTOR = new BigDecimal(2);        DipClassifierConstant.DOWN_LIMIT_FACTOR = new BigDecimal(&quot;0.5&quot;);    &#125;&#125;\n\n使用Classifier@RestController@RequestMapping(&quot;/setlList&quot;)public class CaseController &#123;    @Resource    private Classifier classifier;    @PostMapping(&quot;/classify&quot;)    public ClassifyResult classify(@RequestBody NationSetlList setlList) &#123;        //根据政策文件要求输入金额(医疗总费用或医保总费用)          ClassifyResult classifyResult = classifier.handle(setlList, setlList.getSetlInfo().getMedfeeSumamt());        return classifyResult;    &#125;&#125;\n\n\nNationSetlList是约定的结算清单数据传输对象Classifier是classify包中的一个分组器接口，实现对病案的分组ClassifyResult是分组结果的返回格式\n\n","categories":["项目"],"tags":["Java","Healthcare Boot"]},{"title":"欢迎来到lostred.info","url":"/posts/index.html","content":"施工中…\n","categories":["随笔"],"tags":["杂项"]},{"title":"Healthcare Filter","url":"/posts/healthcare-filter.html","content":"Healthcare Filter提供了一套针对结算清单字段过滤的解决方案。核心类RuleChain将所有单一职责的规则类连接到一起，形成责任链，对传入的结算清单参数进行校验，返回相应的结果。\n特性\n\n结算清单的整体质控实现模式是若干条校验规则组成的责任链模式，即校验规则链\n校验规则链的规则执行器有两种模式可供选择，默认详细执行器会记录违规字段和违规值，而简单执行器则不会记录违规字段和违规值\n校验规则链的规则迭代器有两种模式可供选择，默认全量迭代器会依次通过所有校验规则校验，除非在质控结果中包含”US”校验规则代号(即唯一校验)的错误记录，而跳出迭代器会在出现错误信息后直接结束校验\n规则执行器每执行一个规则，且发现有违规项目时，会在校验结果中添加一个记录\n经过所有校验规则校验后，会生成一个校验结果返回值，校验结果等级分为“合格”、“可疑”和“违规”\n\n规则类\n\n\nRule是一个核心类，它继承了Judgement和Record接口，分别定义了规则的责任方法、判定方法和记录结果方法。\n规则加载原理\n\n\nRuleChain是一个核心接口，AbstractRuleChain抽象类实现了它，我们直接进入AbstractRuleChain的代码：\npublic abstract class AbstractRuleChain implements RuleChain, ApplicationContextAware, BeanNameAware, InitializingBean &#123;    protected final Logger logger = LoggerFactory.getLogger(this.getClass());    protected GenericApplicationContext applicationContext;    protected RuleInfoService ruleInfoService;    protected LinkedList&lt;Rule&gt; rules = new LinkedList&lt;&gt;();    /**     * 根据校验规则信息往spring容器中注册校验规则     *     * @param ruleInfo 校验规则信息     * @return 校验规则     */    protected Rule register(RuleInfo ruleInfo) &#123;        try &#123;            Class.forName(ruleInfo.getClassName());        &#125; catch (ClassNotFoundException e) &#123;            logger.warn(&quot;没有找到校验规则类 ==&gt; &#123;&#125;&quot;, ruleInfo.getClassName());            return null;        &#125;        BeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();        beanDefinition.setBeanClassName(ruleInfo.getClassName());        if (!applicationContext.containsBean(ruleInfo.beanName())) &#123;            applicationContext.registerBeanDefinition(ruleInfo.beanName(), beanDefinition);            logger.debug(&quot;容器注册 &lt;== &#123;&#125;&quot;, ruleInfo.getClassName());        &#125;        Rule rule = applicationContext.getBean(ruleInfo.beanName(), Rule.class);        rule.setRuleInfo(ruleInfo);        return rule;    &#125;    @Override    public void refresh(List&lt;RuleInfo&gt; ruleInfos) &#123;        if (ruleInfos == null || ruleInfos.isEmpty()) &#123;            return;        &#125;        //将校验校验规则按配置的序列排序        ruleInfos.stream()                .sorted(Comparator.comparing(RuleInfo::getSeq))                .map(this::register)                .filter(Objects::nonNull)                .forEach(e -&gt; this.rules.add(e));        logger.info(&quot;校验规则链(&#123;&#125;)已生成，共启用&#123;&#125;条规则&quot;, beanName, this.rules.size());    &#125;&#125;\n\n可以看到AbstractRuleChain实现了InitializingBean接口，其子类可以重写afterPropertiesSet()方法，该方法会在所有spring的配置完成后执行。而该方法又调用了本类的refresh()的方法，其中refresh()方法从数据库读取规则信息，并调用register()方法。\npublic class QualityRuleChain extends AbstractRuleChain implements ApplicationListener&lt;QualityRuleChangeEvent&gt; &#123;    public QualityRuleChain(RuleInfoService ruleInfoService) &#123;        super(ruleInfoService);    &#125;    @Override    public void onApplicationEvent(QualityRuleChangeEvent qualityRuleChangeEvent) &#123;        qualityRuleChangeEvent.getChangeList().stream()                .filter(e -&gt; e.getEnable() == 0)                .map(RuleInfo::getRuleCode)                .forEach(super::removeRule);        qualityRuleChangeEvent.getChangeList().stream()                .filter(e -&gt; e.getEnable() == 1)                .map(super::register)                .filter(Objects::nonNull)                .forEach(super::addRule);    &#125;    @Override    public void afterPropertiesSet() &#123;        List&lt;RuleInfo&gt; list = ruleInfoService.findEnableByPhase(Phase.QUALITY.getCode());        this.refresh(list);    &#125;&#125;\n\nregister()方法根据数据库查出的className字段信息，反射创建Rule实例对象，并将该对象注册到spring容器中，把所有规则加入集合，组成了一个规则链。\n规则链校验流程\n\n\n\nRuleChain的handle()方法将根据结算清单NationSetlList的唯一标识创建一个QualityResult对象\n将规则链首部规则取出，同结算清单NationSetlList和QualityResult交由规则执行器处理\n规则执行器结束执行后，将规则交由规则迭代器处理获取下一个规则\n当规则链走到链尾时，对QualityResult对象进行判断质控结果\n最终返回QualityResult对象\n\n规则变化事件\n\n\nQualityRuleChain和ScreenRuleChain还实现了ApplicationListener接口，它们分别监听了两个规则变化事件，QualityRuleChangeEvent和ScreenRuleChangeEvent。当使用Spring的ApplicationContext发布这些事件后，这两个规则链则会执行相应的方法，该法方法在onApplicationEvent()中执行，通过这个监听模式，就能够实现在用户修改规则信息表中的启用字段后对规则链中规则的更新，实现RuleChain与规则管理类的解耦。\n","categories":["项目"],"tags":["Java","Healthcare Framework"]},{"title":"Spring Boot自动配置原理","url":"/posts/spring-boot-autoconfigure-principle.html","content":"注入自动配置类\n我们知道，在Spring Boot应用启动时，程序会扫描@SpringBootApplication注解同包下的所有带有@Component注解类的.class文件，通过反射创建实例注入Spring容器。其中@Configuration是@Component的复合注解，配置类通常用@Configuration标注，这样配置类也会被注入到Spring容器。\n由于自动配置类往往和@SpringBootApplication标注的启动类不在一个包下，这样自动配置类并不会被注入到容器中，那么Spring Boot如何找到这些自动配置类呢？下面我们进入@SpringBootApplication的源码。\n@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited// 复合注解，包含了@Configuration和@Component，也就是启动类本身也是一个Spring组件@SpringBootConfiguration// 启动自动配置@EnableAutoConfiguration// 包扫描，根据该注解，程序在启动时会默认扫描包下面的所有类的.class文件，反射创建实例并注入容器@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\t\t@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123;&#125;\n\n@SpringBootApplication也是一个复合注解，@SpringBootConfiguration和@ComponentScan我们已经知道了它们的作用，那么自动配置的原理只可能在@EnableAutoConfiguration这个注解中了。\n注解@EnableAutoConfiguration进入@EnableAutoConfiguration源码，发现@EnableAutoConfiguration也是一个复合注解，其中@AutoConfigurationPackage利用AutoConfigurationPackages.Registrar类给容器中导入一系列组件，这里不做详细的说明。\n@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage// 向容器中注入AutoConfigurationImportSelector类的一个实例Bean对象@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123;&#125;\n\n@Import(AutoConfigurationImportSelector.class)这个注解表示会注入AutoConfigurationImportSelector的Bean对象，AutoConfigurationImportSelector实现了ImportSelector接口，其作用是筛选出需要注入容器的类名。\npublic class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered &#123;    // 通过注解元数据选择要注入容器的类名    @Override    public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;        if (!isEnabled(annotationMetadata)) &#123;            return NO_IMPORTS;        &#125;        AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader            .loadMetadata(this.beanClassLoader);        // 获取自动配置类映射        AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata,                                                                                  annotationMetadata);        return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());    &#125;    protected AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata,                                                               AnnotationMetadata annotationMetadata) &#123;        if (!isEnabled(annotationMetadata)) &#123;            return EMPTY_ENTRY;        &#125;        AnnotationAttributes attributes = getAttributes(annotationMetadata);        // 获取候选配置类        List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);        configurations = removeDuplicates(configurations);        Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);        checkExcludedClasses(configurations, exclusions);        configurations.removeAll(exclusions);        configurations = filter(configurations, autoConfigurationMetadata);        fireAutoConfigurationImportEvents(configurations, exclusions);        return new AutoConfigurationEntry(configurations, exclusions);    &#125;    protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;        // 获取配置类的全限定名集合        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());        Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;                        + &quot;are using a custom packaging, make sure that file is correct.&quot;);        return configurations;    &#125;&#125;\n\n最终调用了SpringFactoriesLoader的静态方法loadFactoryNames()。\npublic final class SpringFactoriesLoader &#123;    public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;;    public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader) &#123;        String factoryTypeName = factoryType.getName();        return loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());    &#125;    private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123;        MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);        if (result != null) &#123;            return result;        &#125;                try &#123;            Enumeration&lt;URL&gt; urls = (classLoader != null ?                                     // 读取资源路径中的文件META-INF/spring.factories                                     classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :                                     ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));            result = new LinkedMultiValueMap&lt;&gt;();            while (urls.hasMoreElements()) &#123;                URL url = urls.nextElement();                UrlResource resource = new UrlResource(url);                Properties properties = PropertiesLoaderUtils.loadProperties(resource);                for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;                    String factoryTypeName = ((String) entry.getKey()).trim();                    for (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;                        result.add(factoryTypeName, factoryImplementationName.trim());                    &#125;                &#125;            &#125;            cache.put(classLoader, result);            return result;        &#125;        catch (IOException ex) &#123;            throw new IllegalArgumentException(&quot;Unable to load factories from location [&quot; +                                               FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex);        &#125;    &#125;&#125;\n\n到这里我们发现，Spring最终会在类路径的resources文件夹下读取META-INF/spring.factories中的所有键值对，并转换为Map&lt;String, List&gt;集合返回，Spring通过这个集合通过反射等一些列操作，将自动配置类的Bean对象注入容器。\nspring.factories来到spring-boot-autoconfigure包下的spring.factories。\n# Initializersorg.springframework.context.ApplicationContextInitializer=\\org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\\org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener# Application Listenersorg.springframework.context.ApplicationListener=\\org.springframework.boot.autoconfigure.BackgroundPreinitializer# Auto Configuration Import Listenersorg.springframework.boot.autoconfigure.AutoConfigurationImportListener=\\org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener# Auto Configuration Import Filtersorg.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\\org.springframework.boot.autoconfigure.condition.OnBeanCondition,\\org.springframework.boot.autoconfigure.condition.OnClassCondition,\\org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\org.springframework.boot.autoconfigure.cloud.CloudServiceConnectorsAutoConfiguration,\\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveRestClientAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\\org.springframework.boot.autoconfigure.elasticsearch.rest.RestClientAutoConfiguration,\\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\\org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\\org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketRequesterAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketServerAutoConfiguration,\\org.springframework.boot.autoconfigure.rsocket.RSocketStrategiesAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\\org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\\org.springframework.boot.autoconfigure.security.rsocket.RSocketSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyAutoConfiguration,\\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,\\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,\\org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,\\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration# Failure analyzersorg.springframework.boot.diagnostics.FailureAnalyzer=\\org.springframework.boot.autoconfigure.diagnostics.analyzer.NoSuchBeanDefinitionFailureAnalyzer,\\org.springframework.boot.autoconfigure.flyway.FlywayMigrationScriptMissingFailureAnalyzer,\\org.springframework.boot.autoconfigure.jdbc.DataSourceBeanCreationFailureAnalyzer,\\org.springframework.boot.autoconfigure.jdbc.HikariDriverConfigurationFailureAnalyzer,\\org.springframework.boot.autoconfigure.session.NonUniqueSessionRepositoryFailureAnalyzer# Template availability providersorg.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider=\\org.springframework.boot.autoconfigure.freemarker.FreeMarkerTemplateAvailabilityProvider,\\org.springframework.boot.autoconfigure.mustache.MustacheTemplateAvailabilityProvider,\\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAvailabilityProvider,\\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafTemplateAvailabilityProvider,\\org.springframework.boot.autoconfigure.web.servlet.JspTemplateAvailabilityProvider\n\norg.springframework.boot.autoconfigure.EnableAutoConfiguration这个key下的所有全限定类名就是Spring官方写好的所有自动配置类。因此，只要我们在自己的工程中创建一个META-INF/spring.factories，并将自动配置类的全限定类名写在org.springframework.boot.autoconfigure.EnableAutoConfiguration的key下，就会被Spring扫描并注入容器。\n配置条件注解\nSpring官方写好了许多的自动配置类，但这些类并不会全部生效，原因就在于Spring定义了许多配置条件注解@ConditionalOnXxx，只有满足了这些条件注解，配置类的方法才会被调用，从而生效。\n@ConditionalOnProperty\t\t\t//配置项目满足条件才会生效@ConditionalOnBean\t\t\t//容器中有某个Bean时才会生效@ConditionalOnMissingBean\t\t//容器中没有某个Bean时才会生效@ConditionalOnClass\t\t\t//类路径中有某个类时才会生效@ConditionalOnMissingClass\t\t//类路径中没有某个类时才会生效@ConditionalOnExpression\t\t//根据表达式判断是否生效@ConditionalOnSingleCandidate\t        //容器中某个Bean只有单个候选时才生效@ConditionalOnResource\t\t\t//类路径的资源路径存在某个资源时才生效@ConditionalOnJndi\t\t\t//只有指定的资源通过JNDI加载后才生效@ConditionalOnJava\t\t\t//只有运行指定版本的JVM才会生效...\n\n这些注解不仅能在AutoConfiguration类中使用，也可以在开发者自定义的Config配置类中使用。\n\n具体用法可参考源码的doc注释文档\n\n自动配置顺序注解\n以下三个注解只能在自动配置类生效。\n@AutoConfigureBefore\t//在某个自动配置类配置前配置@AutoConfigureAfter\t\t//在某个自动配置类配置后配置@AutoConfigureOrder\t\t//指定顺序，value的数值越小优先级越高\n\nSpring Boot的自动配置类均是通过spring.factories来加载的，它的优先顺序最低；而通过包扫描导入的一般都是自定义的配置类，优先顺序是最高的，在自动配置类之前载入。\n配置绑定\nSpring Boot中的另一重要机制就是application.properties或application.yaml配置文件，这个配置文件中的配置项可与Properties类中的字段进行绑定，从而实现配置文件中的跳转和提示。\n注解@EnableConfigurationProperties我们来看看spring-boot-autoconfigure中的MultipartAutoConfiguration类。\n@Configuration(proxyBeanMethods = false)@ConditionalOnClass(&#123; Servlet.class, StandardServletMultipartResolver.class, MultipartConfigElement.class &#125;)@ConditionalOnProperty(prefix = &quot;spring.servlet.multipart&quot;, name = &quot;enabled&quot;, matchIfMissing = true)@ConditionalOnWebApplication(type = Type.SERVLET)// 启用配置类，将指定类注入容器@EnableConfigurationProperties(MultipartProperties.class)public class MultipartAutoConfiguration &#123;&#125;\n\n注解@EnableConfigurationProperties也是一个复合注解，本质是@Import通过EnableConfigurationPropertiesRegistrar将指定类注入容器。\n\n 通过@Componet注解也可以将Properties类注入容器\n\n注解@ConfigurationProperties该注解的作用是绑定application.properties中的配置项，通过注解的prefix指定配置前缀，类的字段属性为具体的配置项。Spring会将application.properties中配置的值通过setter方法设置到配置类的属性中。因Properties类本身已经在Spring容器中，通过依赖注入和getter方法，其它类就能获取到application.properties配置文件中的值。\n配置元数据\n除了通过绑定Properties类实现application.properties配置项的提示和跳转，还能通过additional-spring-configuration-metadata.json配置。\n&#123;    &quot;groups&quot;:[],    &quot;properties&quot;:[],    &quot;hints&quot;:[]&#125;\n\n\n更多配置元数据的介绍可参考官方文档：Configuration Metadata (spring.io)\n\n","categories":["Java"],"tags":["Java","Spring Boot"]}]